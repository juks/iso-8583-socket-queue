var iso8583Queue     = require('iso8583-queue');
var iso8583Packet    = require('iso8583-packet');
var moment           = require("moment");

var maxRetry = 10;

function Iso8583Logic(upstream) {
  this.upstream = upstream;
  this.name = 'Iso8583.Logic';
}

Iso8583Logic.prototype.hasGone = function(qe) {
  if (!qe.isSystemSender && !qe.isProcessed) {
    return;
  }

  var now = moment(new Date());
  this.name = 'Iso8583.Logic #' + qe.id;

  if (qe.retryCount == maxRetry) {
    dd(('Warning: reached max retry count for ' + qe.senderName + '. Giving up!\n' + qe.packet.pretty()).yellow);

    return;
  }

  if (qe.packet.hasErrors()) {
    dd('Iso8583.Logic: message contains check errors. Will not process');

    return;
  }

  // Purchase 200
  if (qe.packet.messageTypeId == 200) {
    if (qe.packet.getField(37)) {
      dd('Error: unconfirmed 200 messages has no track2 data. Will not do auto-reversal');

      return;
    }

    dd('Sending auto-reversal message. Merchant: ' + qe.packet.getField(42) + '; terminal: ' +  qe.packet.getField(41) + '; stan: ' + qe.packet.getField(11));

    var p = new iso8583Packet(qe.packet);
    p.setFields({
       0:   400,
       7:   now.format("MMDDHHmmss"),                    // Data & Time, Transmission
       24:  400
    });

    this.upstream.sendData(this, p);
  // Auto-Reverse 400
  } else if (qe.packet.messageTypeId == 400 && qe.isSystemSender) {
    if (!qe.retryCount) {
      var timeout = 0
    } else if (qe.retryCount == 1) {
      var timeout = 2000;
    } else if (qe.retryCount < 8) {
      var timeout = 10000;
    } else {
      var timeout = 60000;
    }

    var p = new iso8583Packet(qe.packet);
    p.setFields({
      7: now.format("MMDDHHmmss")                    // Data & Time, Transmission
    });

    this.upstream.sendData(this, p, {
                      parent:     qe,
                      delayTime: timeout,
                      comment: 'Repeating auto-reversal message. Merchant: ' + qe.packet.getField(42) + '; terminal: ' +  qe.packet.getField(41) + '; stan: ' + qe.packet.getField(11) + '. Attempt ' + (qe.retryCount + 1)
                    });
  }
}

Iso8583Logic.prototype.queueTimeout = function() {
  this.upstream.hasGone(this.queueMessageId);
}

Iso8583Logic.prototype.isClosed = function() {
  return false;
}

Iso8583Logic.prototype.end = function() {

}

Iso8583Logic.prototype.reply = function(p) {
  dd(this.name + ' got reply');

  return true;
}

module.exports = Iso8583Logic;
